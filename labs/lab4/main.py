import pycosat

def encode_boolean_var(r, c, v):
    '''
    We encode every possible value for every cell in the sudoku grid as a boolean variable.
    The variable is unique for each cell and value.
    The encoding is done by the formula (which is similar to decimal number system):
    9^2 * (r - 1) + 9 * (c - 1) + v
    where r is the row, c is the column, and v is the value.
    r = Row index (0 to 8)
    c = Column index (0 to 8)
    v = Digit (1 to 9)
    The variable is a number between 1 and 729 and will be unique to each cell and each possible value.
    '''
    return (9**2) * r + (9) * c + v

def decode_boolean_var(var):
    '''
    The decoding is done by reversing the encoding formula.
    The formula is:
    v = (var - 1) % 9 + 1       -- we have to do theis because if we have the value as 9 we'll get 0 as the remainder so we subtract 1 and add 1 to the remainder
    c = ((var - 1) % 81) // 9   -- we get the divide the remainder we get from modulus by 9 which will result in a value between 0 and 8
    r = (var - 1) // 81         -- we get the value by dividing the variable by 81
    '''
    v = (var - 1) % 9 + 1 
    c = ((var - 1) % 81) // 9 
    r = (var - 1) // 81 
    return (r, c, v)

def generate_clauses(sudoku):
    '''
    This function generates the clauses for the sudoku problem.
    The clauses are generated by the following rules:
    1. Each cell must have a value between 1 and 9.
    2. Each cell must have exactly one value.
    3. Each row must have each value exactly once.
    4. Each column must have each value exactly once.
    5. Each 3x3 block must have each value exactly once.
    The 6th Clause is that the given values in the sudoku grid must be satisfied.
    The 6th Clause is applied in the main function.
    '''
    clauses = []
    
    # Clause 1: Each cell must have a value between 1 and 9
    for r in range(9):
        for c in range(9):
            clauses.append([encode_boolean_var(r, c, v) for v in range(1, 10)])
    
    # Clause 2: Each cell must have exactly one value
    for r in range(9):
        for c in range(9):
            for v1 in range(1, 10):
                for v2 in range(v1 + 1, 10):
                    clauses.append([-encode_boolean_var(r, c, v1), -encode_boolean_var(r, c, v2)])
    
    # Clause 3: Each row must have each value exactly once
    for r in range(9):
        for v in range(1, 10):
            for c1 in range(9):
                for c2 in range(c1 + 1, 9):
                    clauses.append([-encode_boolean_var(r, c1, v), -encode_boolean_var(r, c2, v)])
    
    # Clause 4: Each column must have each value exactly once
    for c in range(9):
        for v in range(1, 10):
            for r1 in range(9):
                for r2 in range(r1 + 1, 9):
                    clauses.append([-encode_boolean_var(r1, c, v), -encode_boolean_var(r2, c, v)])
    
    # Clause 5: Each block must have each value exactly once
    for block_r in range(3):
        for block_c in range(3):
            for v in range(1, 10):
                for i in range(3):
                    for j in range(i + 1, 3):
                        clauses.append([-encode_boolean_var(block_r * 3 + i, block_c * 3 + j, v), -encode_boolean_var(block_r * 3 + j, block_c * 3 + i, v)])
    return clauses

def puzzle_to_cnf(sudoku):
    '''
    The input is the sudoku puzzle in the form of a string and convert it ot cnf clauses.
    This function takes the sudoku puzzle as input and generates the clauses for the sudoku problem.
    The clauses are generated by the generate_clauses function.
    The given values in the sudoku grid are added as clauses.
    We store this as the cnf
    '''
    cnf = generate_clauses(sudoku)
    
    # Clause 6: The given values in the sudoku grid must be satisfied
    for i, char in enumerate(sudoku):
        if char != '.':
            r = i // 9
            c = i % 9
            v = int(char)
            cnf.append([encode_boolean_var(r, c, v)])
    return cnf

def solve_sudoku(filename='p.txt'):
    '''
    We input the sudoku puzzles form the file and generate the solutions and 
    output it to another file.
    '''
    with open(filename, 'r') as f:
        puzzles = [line.strip() for line in f]
    solutions=[]
    for puzzle in puzzles:
        cnf = puzzle_to_cnf(puzzle)
        solution = pycosat.solve(cnf)
        if solution == "UNSAT":
            solutions.append("No solution")
        else:
            solved_sudoku = [[0 for _ in range(9)] for _ in range(9)]
            for var in solution:
                if var > 0:
                    r, c, v = decode_boolean_var(var)
                    solved_sudoku[r][c] = v
            sol_string = ""
            for row in solved_sudoku:
                sol_string += ''.join(str(num) for num in row)
            solutions.append(sol_string)
    with open('output.txt', 'w') as f:
        for solution in solutions:
            f.write(solution + '\n')
    print("Solutions written to output.txt")


if __name__ == "__main__":
    
    solve_sudoku()